# 数字三角形

## Description

给出如下图的数字三角形，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？

![HDU2084](I:\图床\HDU2084.jpg)

## Input

输入数据首先包括一个整数T,表示测试实例的个数。

每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度。

接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。

## Output

对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。

## Sample Input

```
1
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

## Sample Output

```
30
```

HDU 2084



# 最长递增子序列

## Description

给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）

例如: 1 3 2 5 4 7 6 9 8, 最长递增子序列为1 3 5 7 9



## Input

输入数据首先包括一个整数T(1 <= 10),表示测试实例的个数。

每个测试实例的第一行是一个整数N(2 <= N <= 5000)，表示序列的长度。

第二行数字是一组数组，且所有的整数均在区间[0,1,000,000]内。

## Output

对于每个测试实例，输出最长递增子序列的长度，每个实例的输出占一行。

## Sample Input

```
1
9
1 3 2 5 4 7 6 9 8
```

## Sample Output

```
1 3 5 7 9
```



# 最长公共子序列

## Description

求两个序列的最长公共子序列，都为小写字母。

## Input

每组测试样例都为一行，两组字符串，每组不超过1000，用空格隔开。

## Output

对于每个测试实例，输出最长公共子序列的长度，每个实例的输出占一行。

## Sample Input

```
abcfbc abfcab
programming contest 
abcd mnp
```

## Sample Output

```
4
2
0
```

HDU 1159
# 连续数组最大和问题 // 4

## Description

求最大连续子段和，并输出此子段的起始位置和终止位置的值。

例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。

## Input

测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( < 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。

## Output

对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元
素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。

## Sample Input

```
6
-2 11 -4 13 -5 -2
10
-10 1 2 3 4 -5 -23 3 7 -21
6
5 -8 3 2 5 0
1
10
3
-1 -5 -2
3
-1 0 -2
0
```

## Sample Output

```
20 11 13
10 1 4
10 3 5
10 10 10
0 -1 -2
0 0 0
```

HDU 1231



# 01背包

## Description

如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。

## Input

多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n<=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m<=1000。

n=0表示数据结束。

## Output

对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。

## Sample Input

```
1
50
5
10
1 2 3 2 1 1 2 3 2 1
50
0
```

## Sample Output

```
-45
32
```

HDU 2546



# 合并石子

## Description

在一个圆形操场的四周摆放 N 堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 N堆石子合并成 1堆的最小得分和最大得分。

## Input

数据的第 1行是正整数 N，表示有 N 堆石子。

第 2 行有 N 个整数，第 i个整数 ai 表示第 i 堆石子的个数。

## Output

输出共 2 行，第 1 行为最小得分，第 2 行为最大得分。

## Sample Input

```
4
4 5 9 4
```

## Sample Output

```
43
54
```

![image-20210823142635810](C:\Users\西南城角\AppData\Roaming\Typora\typora-user-images\image-20210823142635810.png)

NOIP 1995


